# [（简单）27. 移除元素](https://leetcode-cn.com/problems/remove-element/)
## **题目描述**
>给你一个数组 *nums* 和一个值 *val*，你需要原地移除所有数值等于 *val* 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

### **示例1**
>给定 *nums* = [3,2,2,3], *val* = 3,
>函数应该返回新的长度 2, 并且 *nums* 中的前两个元素均为 2。
>你不需要考虑数组中超出新长度后面的元素。

### **示例2**
>给定 *nums* = [0,1,2,2,3,0,4,2], *val* = 2,
>函数应该返回新的长度 5, 并且 *nums* 中的前两个元素均为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。
>你不需要考虑数组中超出新长度后面的元素。

## **解决方案**
### **方法一：双指针**
```
//Java
public int removeElement(int[] nums, int val) {
    int i = 0;
    for (int j = 0; j < nums.length; j++) {
        if (nums[j] != val) {
            nums[i] = nums[j];
            i++;
        }
    }
    return i;
}
```
## **复杂度分析**
- 时间复杂度：*O(n)*，假设数组总共有 *n* 个元素，*i* 和 *j* 至少遍历 2*n* 步。
- 空间复杂度：*O*(1)。
### **方法二：双指针——当要删除的元素较少时**
```
//Java
public int removeElement(int[] nums, int val) {
    int n=nums.length;
    for(int i = 0;i<n;i++){
        if(nums[i]==val){
            nums[i] = nums[n-1];
            n--;
            i--;
        }
    }
    return n;
}
```
## **复杂度分析**
- 时间复杂度：*O(n)*，*i* 和 *n* 最多遍历 *n* 步。在这个方法中，赋值操作的次数等于要删除的元素的数量。因此，如果要移除的元素很少，效率会更高。
- 空间复杂度：*O*(1)。
